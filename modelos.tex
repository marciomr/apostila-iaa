\chapter{Modelos}

Vimos no Capítulo \ref{} que podemos avaliar o tempo de processamento de um algoritmo usando o método empírico.
Para isso, em algum momento precisamos de um {\em modelo} que iremos testar.
Nos exemplos que vimos o modelo foi tirado intuitivamente a partir das observações.
Há métodos mais adequados para conceber um modelo para o consumo de tempo de um algoritmo.

Vamos mais uma vez considerar os algortimos de busca que temos estudado.

\begin{codebox}
\Procname{$\proc{BuscaSequencial}(A, b)$}
\li \For $i \gets 1$ até $n$
\li \Do \If $a_i = b$
\li     \Then \Return $i$
        \End
    \End
\li \Return $\bot$
\End
\end{codebox}

Quando esse algoritmo for implementado e executado em uma máquina, as instruções seguidas tomarão um tempo que depende de uma série de fatores.
A atualização da variável $i$ na linha 1, por exemplo, deve tomar um tempo.
Digamos que esse tempo seja representao por $c_1$.
A comparação de $a_i$ com $b$ na linha 2 deve tomar algum tempo, digamos $c_2$.
Devolver um valor na linha 3 tomará tempo $c_3$ e devolver o erro na linha 4 tomará tempo $c_4$.

Não sabemos exatamente quanto é esse tempo e ele deve variar dependendo da máquina, do sistema operacional e outros fatores.
A suposição que faremos é apenas que o tempo é constante.
Deve variar ligeiramente o tempo que uma máquina leva para atualizar a variável $i$, mas essa variação deve ficar em torno de uma média.
Portanto, é razoável supor que esse tempo é constante.

O que devemos fazer, então é contar o número de vezes que cada operações ocorre.
A primeira e a segunda linha ocorrerão no máximo $n$ vezes.
Já a terceira e a quarta linha no máximo uma vez.
Assim, um bom modelo para o cosumo de tempo que este algoritmo deve tomar em função do tamanho da sequência $n$ é:

\begin{displaymath}
  t(n) \leq c_1.n + c_2.n + c_3 + c_4 
\end{displaymath}

Nosso modelo varia com o tamanho e com os valores da entrada.
Se quisermos um modelo que varia apenas com o tamanho, precisamos fazer alguma suposição.
Na maior parte deste curso faremos uma {\em análise de pior caso}.
No nosso exmeplo, o pior caso ocorre quando o elemento $b$ não está na sequência $A$.

Em algumas situações específicas é útil fazer uma análise de caso médio.
Mas em geral não conhecemos o suficiente sobre a distribuição de probabilidade da entrada.
Uma análise de pior caso nos dá um limite de quanto tempo o processamento dos dados tomará levando em conta apenas o tamanho da entrada.

No nosso caso, o modelo ficaria assim:

\begin{displaymath}
  t(n) = c_1.n + c_2.n + c_3 + c_4 = (c_1 + c_2).n + c_3 + c_4 = a.n + b
\end{displaymath}

Note que chegamos no mesmo modelo que apresentamos no Capítulo \ref{}.

Vamos agora replicar esse mesmo tipo de análise para nosso outro algoritmo.
\begin{codebox}
  \Procname{$\proc{BuscaBinaria}(A, b)$}
  \li $i \gets 1$
  \li $j \gets |A|$
  \li \While $i \leq j$
  \li \Do $m \gets \left \lfloor{\frac{j+i}{2}}\right\rfloor$
  \li \If $b < a_m$
  \li     \Then $j \gets m - 1$
  \li \Else
      \If $b > a_m$
  \li      \Then $i \gets m + 1$
  \li \Else \Return m 
      \End
  \End
  \End
  \li \Return $\bot$
\end{codebox}

Vamos atribuir constantes $c_1, dots, c_{10}$ para o tempo de processamento de cada uma das 10 linhas do algoritmo.
Agora vamos contar as linhas.
As linhas 1, 2 serão executadas uma vez cada.
Contar as demais linhas é mais complicado.

Primeiro vamos lembrar que faremos uma análise de pior caso.
Assim, a linha 9 não será executada nunca e a 10 será executada apenas uma vez.
Outra observação é que toda vez que executarmos a linha 4, executaremos ou as linhas 5 e 6 ou as linhas 7 e 8.
Para simplificar, vamos supor que o tempo de execução da linha 5 é o mesmo que da 7 ($c_5$) e que o tempo de execução da linha 6 é o mesmo que da 8 ($c_6$).
Digamos que entremos $x$ vezes no laço.
Então nosso modelo até aqui é:

\begin{displaymath}
  t(n) = c_3.x + c_4.x + c_5.x + c_6.x + c_1 + c_2 + c_{10} = (c_3 + c_4 + c_5).x + c_1 + c_2 + c_{10} = a.x + b 
\end{displaymath}

Precisamos agora calular $x$ em termos de $n$.

Para simplificar ainda mais um pouco nosso trabalho, vamos supor que o tamanho da sequência $n$ é uma potência de 2, ou seja, $n = 2^y$ para algum $y$.
Agora note que cada vez que entramos no laço, metade da sequência é descartada.

Na primeira iteração o pedaço da sequência que estamos considerando é $n = 2^y$.
Na segunda iteração ele tem tamanho $\frac{n}{2} = 2^{y-1}$.
Na terceira ele tem tamanho $\frac{n}{4} = 2^{y-2}$
Esse processo ira continuar até que o tamanho da nossa sequência seja $1 = 2^0$.
Ou seja, do começo ao final do processo as linhas 3 - 6 serão executadas $y$ vezes.
Como $n = 2^y$ temos que $y = log_2(n)$.

Neste curso, o logaritmo na base 2 será tão comum que vale a pena usar uma abreviação para ele.
Escreveremos apenas $lg$.

Assim, nosso modelo fica:
\begin{displaymath}
  t(n) = a.lg(n) + b 
\end{displaymath}

Mais uma vez, o modelo que chegamos ao contar o número de repetições de cada linha coincide com o modelo que chegamos a partir das observações.


